// src/ai/flows/get-trending-products.ts
'use server';
/**
 * @fileOverview Generates a list of currently trending products by analyzing social media data.
 *
 * - getTrendingProducts - A function that generates a list of trending products.
 * - TrendingProductsOutput - The return type for the getTrendingProducts function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import type { Product, SocialPlatform } from '@/lib/types';
import fetch from 'node-fetch';

const ProductReviewSchema = z.object({
    platform: z.enum(['Twitter', 'Reddit']).describe("The social media platform (e.g., 'Twitter', 'Reddit')."),
    text: z.string().describe("The full text of the social media post."),
    username: z.string().describe("The username of the author of the post."),
    postUrl: z.string().url().describe("The direct URL to the social media post."),
});

// Removed fetchInstagramData and fetchTikTokData

const fetchTwitterData = async (query: string) => {
    const bearerToken = process.env.X_BEARER_TOKEN;
    if (!bearerToken) {
        console.warn(`X_BEARER_TOKEN not found for query "${query}". Returning empty array.`);
        return [];
    }

    const url = `https://api.twitter.com/2/tweets/search/recent?query=${encodeURIComponent(query)}&tweet.fields=text,author_id,id&expansions=author_id&max_results=5`;

    try {
        const response = await fetch(url, { headers: { 'Authorization': `Bearer ${bearerToken}` } });
        const data: any = await response.json();

        if (!response.ok || !data.data) {
            console.error(`Failed to fetch Twitter data for "${query}":`, data.errors?.[0]?.message || 'Unknown error');
            return [];
        }

        const users = new Map(data.includes?.users?.map((user: any) => [user.id, user.username]) || []);

        return data.data.map((tweet: any) => ({
            platform: 'Twitter' as const,
            text: tweet.text || '',
            username: users.get(tweet.author_id) || 'twitter_user',
            postUrl: `https://twitter.com/${users.get(tweet.author_id) || 'i'}/status/${tweet.id}`,
        }));
    } catch (error) {
        console.error(`Error fetching Twitter data for "${query}":`, error);
        return [];
    }
};

const fetchRedditData = async (query: string) => {
    // Assuming you will add REDDIT_CLIENT_ID and REDDIT_CLIENT_SECRET to your .env
    const clientId = process.env.REDDIT_CLIENT_ID;
    const clientSecret = process.env.REDDIT_CLIENT_SECRET;
    // You might need a more complex OAuth flow for Reddit depending on permissions
    // This simplified version uses a user agent and assumes public data access
    // based on the original code structure.
    if (!clientId || !clientSecret) {
         console.warn(`REDDIT_CLIENT_ID or REDDIT_CLIENT_SECRET not found for query "${query}". Returning empty array.`);
         // return []; // Depending on Reddit API requirements, you might still get some public data
    }

    const url = `https://www.reddit.com/search.json?q=${encodeURIComponent(query)}&limit=5&sort=hot`;
    try {
        const response = await fetch(url, { headers: { 'User-Agent': 'node:firebase-studio-app:v1.0' } });
        if (!response.ok) {
            console.error('Failed to fetch Reddit data:', response.statusText);
            return [];
        }
        const data: any = await response.json();
        if (!data.data || !data.data.children) return [];

        return data.data.children.map((post: any) => ({
            platform: 'Reddit' as const,
            text: post.data.title || '',
            username: post.data.author || 'reddit_user',
            postUrl: `https://www.reddit.com${post.data.permalink || ''}`,
        }));
    } catch (error) {
        console.error(`Error fetching Reddit data for "${query}":`, error);
        return [];
    }
};


const TrendingProductSchema = z.object({
  id: z.string().describe("A unique product ID, e.g., 'prod-001'"),
  name: z.string().describe('The name of the product.'),
  category: z.string().describe('The category the product belongs to.'),
  forecastedDemand: z.number().describe('The estimated weekly demand for this product.'),
  inventoryStatus: z.enum(['Optimal', 'Overstock', 'Understock']).describe('The current inventory status based on the trend.'),
  lastUpdated: z.string().describe("A human-readable string indicating when this data was generated, e.g., 'Just now' for live data or 'Generated by AI' for fallback data."),
  imageUrl: z.string().url().describe('A valid placeholder image URL from \'https://placehold.co\' with a size of 64x64.'),
  reviews: z.array(ProductReviewSchema).describe("A list of 2-3 of the most representative social media posts that signal this trend.")
});

const TrendingProductsOutputSchema = z.object({
    products: z.array(TrendingProductSchema)
});

export type TrendingProductsOutput = z.infer<typeof TrendingProductsOutputSchema>;

export async function getTrendingProducts(): Promise<Product[]> {
    const result = await trendingProductsFlow();
    return result.products as Product[];
}

const prompt = ai.definePrompt({
  name: 'getTrendingProductsPrompt',
  model: 'googleai/gemini-1.5-flash-latest',
  output: {schema: TrendingProductsOutputSchema},
  prompt: `You are the AI engine for "TrendSense," a real-time demand forecasting platform for Walmart. Your primary function is to analyze social media data to identify viral product trends.

You have been provided with a raw data stream of posts from Twitter and Reddit.

Social Media Data:
{{{socialMediaData}}}

Based on this live data, analyze it to identify up to 10 of the most relevant and impactful product trends for Walmart. A higher mention count with positive sentiment should result in higher demand and an 'Understock' status.

For each of the products you identify, you must provide the following information:
- A unique product ID (e.g., prod-001, prod-002).
- The specific product name.
- A plausible Walmart category (e.g., Home Goods, Electronics, Apparel, Beauty, Groceries, Toys).
- A forecasted weekly demand as a number, reflecting its viral velocity.
- An inventory status: 'Understock' for new, explosive trends; 'Optimal' for established trends; 'Overstock' for fading trends.
- A lastUpdated string. Use 'Just now' as you are analyzing live data.
- A valid placeholder image URL from 'https://placehold.co' with a size of 64x64.
- A list of 2-3 of the most representative "reviews" (social media posts) from the provided data that justify why this product is trending. Each review must include the platform, text, username, and the exact postUrl provided in the source data. You MUST NOT alter the postUrl.

Return the list of products in the specified JSON format. You must include reviews for each product.`,
});


const trendingProductsFlow = ai.defineFlow(
  {
    name: 'trendingProductsFlow',
    outputSchema: TrendingProductsOutputSchema,
  },
  async () => {
    const topics = ['air fryer', 'skincare', 'running shoes', 'summer dress', 'gaming keyboard', 'protein powder'];
    let allPosts: any[] = [];

    for (const topic of topics) {
        // Only fetch data from Twitter and Reddit
        const [twitter, reddit] = await Promise.all([
            fetchTwitterData(topic),
            fetchRedditData(topic)
        ]);
        allPosts = [...allPosts, ...twitter, ...reddit];
    }

    const uniquePosts = Array.from(new Map(allPosts.map(p => [p.text, p])).values());

    if (uniquePosts.length === 0) {
        console.log("No social media data fetched from Twitter or Reddit. Returning fallback data.");
        return getFallbackProducts();
    }

    const socialMediaData = JSON.stringify(uniquePosts, null, 2);

    console.log("-----BEGIN SOCIAL MEDIA ANALYSIS-----\n");
    console.log(`Sending ${uniquePosts.length} unique posts from Twitter and Reddit to the AI model.\n`);
    console.log("-----END SOCIAL MEDIA ANALYSIS-----\n");


    try {
        const {output} = await prompt({ socialMediaData });
        return output!;
    } catch (error) {
        console.error("AI call failed. This is likely due to API quota limits or another error. Returning fallback data.", error);
        return getFallbackProducts();
    }
  }
);

function getFallbackProducts(): TrendingProductsOutput {
  return {
    products: [
      {
        id: 'fallback-001',
        name: 'e.l.f. Halo Glow Liquid Filter',
        category: 'Beauty',
        forecastedDemand: 2200,
        inventoryStatus: 'Understock',
        lastUpdated: 'Generated by AI',
        imageUrl: 'https://placehold.co/64x64',
        reviews: [
          // Keeping these fallback reviews, but in a real scenario,
          // you might want to adjust or remove reviews from platforms
          // you are no longer scraping.
          { platform: 'TikTok', text: 'This is my secret weapon for glowy skin, literally a filter in a bottle. ✨ #elfhaloglow #haloglowliquidfilter #makeupdupes', username: 'glamzilla', postUrl: 'https://www.tiktok.com/@glamzilla/video/7115822262219443462' },
          { platform: 'Instagram', text: 'The hype is real! ✨ The @elfcosmetics Halo Glow Liquid Filter is a must-have for that perfect dewy look. #elfcosmetics #haloglow', username: 'mikaylanogueira', postUrl: 'https://www.instagram.com/p/CgToaBfA9gN/' }
        ],
      },
      {
        id: 'fallback-002',
        name: 'Ninja CREAMi Ice Cream Maker',
        category: 'Home Goods',
        forecastedDemand: 1800,
        inventoryStatus: 'Understock',
        lastUpdated: 'Generated by AI',
        imageUrl: 'https://placehold.co/64x64',
        reviews: [
            { platform: 'TikTok', text: 'I am obsessed with my Ninja CREAMi. Making protein ice cream has never been easier or tastier! #ninjacreami #proteinicecream', username: 'kristieleyton', postUrl: 'https://www.tiktok.com/@kristieleyton/video/7243924712413367594' },
            { platform: 'Reddit', text: 'I finally caved and bought a Ninja Creami. The texture is incredible, way better than any store-bought low-cal ice cream. Worth it.', username: 'FitFoodieFinds', postUrl: 'https://www.reddit.com/r/ninjacreami/comments/1axce2t/is_it_worth_it/' }
        ],
      },
      {
        id: 'fallback-003',
        name: 'Hoka Running Shoes',
        category: 'Apparel',
        forecastedDemand: 1500,
        inventoryStatus: 'Optimal',
        lastUpdated: 'Generated by AI',
        imageUrl: 'https://placehold.co/64x64',
        reviews: [
            { platform: 'Instagram', text: 'Clocking in the miles with my new Hokas! It feels like running on clouds. ☁️ #hoka #running #marathontraining', username: 'emilyabbate', postUrl: 'https://www.instagram.com/p/C9m6d45RIzJ/' },
            { platform: 'Twitter', text: 'Just PR\'d my 5k time and I\'m giving 90% of the credit to my new Hoka Clifton 9s. Game changer.', username: 'RunnersWorld', postUrl: 'https://twitter.com/runnersworld/status/1765791283832328639'}
        ],
      },
      {
        id: 'fallback-004',
        name: 'Stanley Quencher Tumbler',
        category: 'Drinkware',
        forecastedDemand: 950,
        inventoryStatus: 'Optimal',
        lastUpdated: 'Generated by AI',
        imageUrl: 'https://placehold.co/64x64',
        reviews: [
            { platform: 'Instagram', text: 'My Stanley goes everywhere with me. Staying hydrated has never been so stylish. #stanleycup #hydration', username: 'thesisterstudioig', postUrl: 'https://www.instagram.com/p/C2FLZ2_L2aC/' },
        ],
      },
      {
        id: 'fallback-005',
        name: 'Bissell Little Green Machine',
        category: 'Home Goods',
        forecastedDemand: 700,
        inventoryStatus: 'Overstock',
        lastUpdated: 'Generated by AI',
        imageUrl: 'https://placehold.co/64x64',
        reviews: [
          { platform: 'TikTok', text: 'You NEED this Bissell Little Green cleaner. Watch it erase this stain like magic! So satisfying. #cleantok #bisselllittlegreen #cleanwithme', username: 'teresalauracaruso', postUrl: 'https://www.tiktok.com/@teresalauracaruso/video/7112939883313073454' }
        ],
      },
    ],
  };
}
